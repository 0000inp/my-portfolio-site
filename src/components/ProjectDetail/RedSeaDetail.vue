<script setup>
import { ref } from 'vue'
import VCodeBlock from '@wdns/vue-code-block';

</script>

<template>

    <div class="flex justify-between">
      <h2 class="text-3xl font-semibold mb-1">Red Sea</h2>
      <div class="flex gap-2 mt-2.5">
        <img src="../../assets/logo/unreal-engine.svg" class="w-8 h-8">
        <img src="../../assets/logo/blender.svg" class="w-8 h-8">
        <svg class="mt-0.5" width="30" height="30" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
        <g id="c++">
        <g id="c++_2">
        <path id="Vector" d="M94.7304 29.3213C94.7297 27.6444 94.371 26.1626 93.6458 24.8908C92.9333 23.6402 91.8664 22.5921 90.4353 21.7633C78.6222 14.9519 66.7977 8.16125 54.9885 1.34284C51.8048 -0.495164 48.7179 -0.428157 45.5578 1.43624C40.8559 4.20922 17.3148 17.6964 10.2999 21.7595C7.41097 23.4319 6.00521 25.9914 6.00451 29.3181C6 43.0164 6.00451 56.7143 6 70.4129C6.00069 72.0531 6.34406 73.506 7.0374 74.7587C7.75017 76.0471 8.83201 77.1241 10.2961 77.9715C17.3114 82.0347 40.8555 95.5208 45.5565 98.2945C48.7179 100.16 51.8048 100.227 54.9895 98.3879C66.7991 91.5691 78.6243 84.7789 90.4391 77.9674C91.9032 77.1202 92.985 76.0426 93.6978 74.7552C94.3901 73.5026 94.7342 72.0496 94.7349 70.4091C94.7349 70.4091 94.7349 43.0199 94.7304 29.3213Z" fill="#5C8DBC"/>
        <path id="Vector_2" d="M50.5032 49.7322L7.03735 74.7588C7.75013 76.0473 8.83197 77.1242 10.2961 77.9717C17.3113 82.0349 40.8555 95.521 45.5565 98.2947C48.7179 100.16 51.8048 100.227 54.9895 98.3881C66.7991 91.5693 78.6244 84.779 90.4392 77.9676C91.9033 77.1204 92.9851 76.0427 93.6979 74.7554L50.5032 49.7322Z" fill="#1A4674"/>
        <path id="Vector_3" d="M37.629 57.1453C40.1583 61.5608 44.913 64.5389 50.3673 64.5389C55.8553 64.5389 60.6371 61.5229 63.1536 57.0602L50.5031 49.7322L37.629 57.1453Z" fill="#1A4674"/>
        <path id="Vector_4" d="M94.7303 29.3216C94.7296 27.6447 94.371 26.1629 93.6457 24.8911L50.5032 49.7324L93.6978 74.7556C94.3901 73.503 94.7342 72.05 94.7349 70.4095C94.7349 70.4095 94.7349 43.0202 94.7303 29.3216Z" fill="#1B598E"/>
        <path id="Vector_5" d="M92.3551 51.5208H88.9798V54.8969H85.6037V51.5208H82.2287V48.1459H85.6037V44.7705H88.9798V48.1459H92.3551V51.5208ZM80.0387 51.5208H76.6637V54.8969H73.2883V51.5208H69.913V48.1459H73.2883V44.7705H76.6637V48.1459H80.0387V51.5208Z" fill="white"/>
        <path id="Vector_6" d="M63.1537 57.0604C60.6373 61.5231 55.8554 64.5392 50.3675 64.5392C44.9131 64.5392 40.1584 61.561 37.6291 57.1455C36.3586 54.9298 35.6913 52.4197 35.6939 49.8656C35.6939 41.7619 42.2637 35.1924 50.3675 35.1924C55.7867 35.1924 60.5164 38.1335 63.0582 42.5039L75.8837 35.1185C70.7859 26.3187 61.2685 20.3984 50.3675 20.3984C34.0927 20.3984 20.8999 33.5916 20.8999 49.8656C20.8999 55.2047 22.3202 60.2115 24.8026 64.5301C29.8875 73.3765 39.4321 79.3332 50.3675 79.3332C61.323 79.3332 70.8824 73.3525 75.96 64.4801L63.1537 57.0604Z" fill="white"/>
        </g>
        </g>
        </svg>
      </div>
    </div>

    <div class="mb-3">
        <p class="text-md opacity-50 text-white inline-flex items-center gap-2"> <span class="pi pi-cog"></span> Under Development</p>
    </div>
    <iframe width="530" height="315" src="https://www.youtube.com/embed/oHWikUBgI2s?si=RYWMtxZ_SxJjlXLy&autoplay=1&rel=0" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

    <p class="mt-1">This is my graduation project. A submarine horror game aim to raise environmental awareness</p>

    <h3 class="font-semibold mt-3">Things I've learned and made</h3>
    <ul class="pl-10" style="list-style-type: disc;">
      <li class="opacity-70">Unreal Engine C++</li>
    </ul>
    
    <div class="my-3">
      <h3><strong class="font-semibold">Sonar system </strong>
        <span class="opacity-70">that can detect nearby enemy when sonar hit</span>
      </h3>
      <video src="../../assets/Project/Red Sea/radar.mp4" class="" autoplay loop muted disablePictureInPicture></video>
    </div>
    

    <div class="my-3">
      <h3><strong class="font-semibold">Fish simulation </strong>
        <span class="opacity-70">using boids algorithm to simulate fish flock behavior, avoid collision and follow target</span>
      </h3>
      <video src="../../assets/Project/Red Sea/fish.mp4" class="" autoplay loop muted disablePictureInPicture></video>
      <VCodeBlock class="text-[10px]" maxHeight="500"
        :code="code"
        highlightjs
        label=""
        lang="c++"
        theme="neon-bunny"
      />
    </div>

</template>


<style scoped>

</style>


<script>
  const code = ref(`// AIFishSchoolPawn.cpp
#include "AIFishSchoolPawn.h"
#include "Kismet/KismetMathLibrary.h"
#include "SummerProject/Dev/DEBUG.h"
#include "Math/UnrealMathUtility.h"

AAIFishSchoolPawn::AAIFishSchoolPawn()
{
    PrimaryActorTick.bCanEverTick = true;

    // Create Instanced Static Mesh Component
    InstancedMeshComponent = CreateDefaultSubobject<UInstancedStaticMeshComponent>(TEXT("InstancedMeshComponent"));
    InstancedMeshComponent->bUseDefaultCollision = false;
    RootComponent = InstancedMeshComponent;

    //Init variable
    FishAmount = 10;
    
    MaxSpeed = 300.0f;
    MaxForce = 10.0f;
    
    TargetWeight = 1.0f;
    CohesionWeight = 1.0f;
    AlignmentWeight = 1.0f;
    SeparationWeight = 1.5f;
    CollisionAvoidanceWeight = 1.0f;
    
    NeighborRadius = 300.0f;
    SeparationRadius = 100.0f;
}

void AAIFishSchoolPawn::BeginPlay()
{
    Super::BeginPlay();
    
    
    if (FishMesh && FishMaterial)
    {
        // Init fish school with the mesh and material
        InitializeFish(FishAmount, FishMesh, FishMaterial);  
    }
    else
    {
        UE_LOG(LogTemp, Warning, TEXT("Failed to load Fish Mesh or Material"));
    }
}

void AAIFishSchoolPawn::Tick(float DeltaTime)
{
    Super::Tick(DeltaTime);
    
    // Update fish movement
    UpdateFishMovement(DeltaTime);
}

void AAIFishSchoolPawn::InitializeFish(int32 NumberOfFish, UStaticMesh* Mesh, UMaterialInterface* Material)
{
    InstancedMeshComponent->SetStaticMesh(Mesh);
    InstancedMeshComponent->SetMaterial(0, Material);
    
    //loop for each fish
    for (int32 i = 0; i < NumberOfFish; ++i)
    {
        FTransform InstanceTransform;
        InstanceTransform.SetLocation(UKismetMathLibrary::RandomUnitVector() * FishSpawnRadius);  //spawn fish in random direction in radius
        InstanceTransform.SetRotation(FQuat::Identity);
        InstanceTransform.SetScale3D(FVector(1.0f));
        
        InstancedMeshComponent->AddInstance(InstanceTransform);
        Velocities.Add(FVector::ZeroVector);
        Accelerations.Add(FVector::ZeroVector);
    }
}

void AAIFishSchoolPawn::UpdateFishMovement(float DeltaTime)
{
    FVector SchoolTarget;
    if(TargetActor){SchoolTarget = TargetActor->GetActorLocation();} //location of target actor
    else{SchoolTarget = GetActorLocation();} //if no target actor swim around in self area
    
    for (int32 i = 0; i < InstancedMeshComponent->GetInstanceCount(); ++i)
    {
        FTransform FishTransform;
        InstancedMeshComponent->GetInstanceTransform(i, FishTransform, true);
        FVector FishLocation = FishTransform.GetLocation();
        FVector Vel = Velocities[i];
        
        TArray<FVector> DirectionData = LoopCompute(i, FishTransform);
        
        FVector TargetForce = SteerToward(SchoolTarget - FishLocation, Vel) * TargetWeight;
        FVector CohesionForce = SteerToward(DirectionData[0], Vel)  * CohesionWeight;
        FVector AlignmentForce = SteerToward(DirectionData[1], Vel) * AlignmentWeight;
        FVector SeparationForce = SteerToward(DirectionData[2], Vel) * SeparationWeight;
        
        Accelerations[i] =  TargetForce + CohesionForce + AlignmentForce + SeparationForce; //รวม force ทั้งหมด
        
        FVector AvoidanceDirection = ComputeCollisionAvoidance(i, FishTransform);
        if(!AvoidanceDirection.IsZero())
        {
            Accelerations[i]+= SteerToward(AvoidanceDirection, Vel) * CollisionAvoidanceWeight;
        }
        Accelerations[i] = Accelerations[i].GetClampedToMaxSize(MaxForce);
        
        Velocities[i] += Accelerations[i] * DeltaTime;
        Velocities[i] = Velocities[i].GetClampedToMaxSize(MaxSpeed);
        
        FVector NewLocation = FishLocation + Velocities[i] * DeltaTime;
        FQuat NewRotation = FQuat::Slerp(FishTransform.GetRotation() ,FQuat(Velocities[i].Rotation()),7.75f * DeltaTime);
        FishTransform.SetLocation(NewLocation);
        FishTransform.SetRotation(NewRotation);
        
        InstancedMeshComponent->UpdateInstanceTransform(i, FishTransform, true);

        if(DrawDebug)
        {
            FVector EndLocation = FishLocation + (Velocities[i] * 15.0f);
            DrawDebugLine(
                GetWorld(),       
                FishLocation,      
                EndLocation,
                FColor::Yellow,
                false,
                -1.0f,
                0,
                2.0f
            );
        }
        
    }
    
    InstancedMeshComponent->MarkRenderStateDirty();  // Update rendering
}

TArray<FVector> AAIFishSchoolPawn::LoopCompute(int32 FishIndex, FTransform FishTransform)
{
    //FishIndex = current fish index 
    TArray<FVector> Output;
    Output.SetNum(4);
    Output[0] = Velocities[FishIndex].GetSafeNormal();
    Output[1] = Velocities[FishIndex].GetSafeNormal();
    Output[2] = Velocities[FishIndex].GetSafeNormal();
    
    FVector FishLocation = FishTransform.GetLocation();
    
    int32 NeighborCount = 0;
    //Chohesion
    FVector CenterOfMass = FVector::ZeroVector;
    //Alignment
    FVector AverageDirection = FVector::ZeroVector;
    //Separation
    int32 SeparationNeighborCount = 0;
    FVector SeparationForce = FVector::ZeroVector;

    //count fish in NeighborRadius and SeparationRadius
    for (int32 j = 0; j < InstancedMeshComponent->GetInstanceCount(); ++j) 
    {
        if (j != FishIndex)
        {
            FTransform OtherTransform;
            InstancedMeshComponent->GetInstanceTransform(j, OtherTransform, true);
            FVector OtherLocation = OtherTransform.GetLocation();
            float Distance = FVector::Dist(FishLocation, OtherLocation);
            if (Distance < NeighborRadius)
            {
                CenterOfMass += OtherLocation;
                AverageDirection += Velocities[j];
                NeighborCount++;
            }
            
            if (Distance < SeparationRadius && Distance > 0)
            {
                SeparationForce += (FishLocation - OtherLocation) / Distance;
                SeparationNeighborCount++;
            }
        }
    }
    
    if (NeighborCount > 0) //if there are other fish NeighborRadius compute mass center and average direction
    {
        CenterOfMass /= NeighborCount;
        AverageDirection /= NeighborCount;
        Output[0] = CenterOfMass - FishLocation.GetSafeNormal(); //output direction to center off mass
        Output[1] = AverageDirection.GetSafeNormal(); //output average direction
    }
    else //if no fish in radius output current direction
    {
        Output[0] = Velocities[FishIndex].GetSafeNormal();
        Output[1] = Velocities[FishIndex].GetSafeNormal();
    }
    
    if (SeparationNeighborCount > 0) //if there are other fish in SeperationRadius radius compute mass center and average direction
    {
        SeparationForce /= NeighborCount;

        Output[2] = SeparationForce.GetClampedToMaxSize(MaxForce); //output seperation force
    }
    else //if no fish in radius output 0 vector (no force)
    {
        Output[2] = FVector::ZeroVector;
    }
    
    return Output;
}

FVector AAIFishSchoolPawn::ComputeCollisionAvoidance(int32 FishIndex, FTransform FishTransform)
{
    FVector FishLocation = FishTransform.GetLocation();
    FVector EndLocation = FishLocation + (Velocities[FishIndex].GetSafeNormal() * CollisonAvoidanceTraceDistance);
    FVector AvoidanceForce = FVector::ZeroVector;
    
    // perform a sphere overlap check to detect nearby obstacles
    TArray<FOverlapResult> OverlapResults;
    FCollisionQueryParams QueryParams;
    QueryParams.AddIgnoredActor(this);  // ignore the owning pawn (self)
    QueryParams.AddIgnoredComponent(InstancedMeshComponent); //ignore all mesh instance

    //line trace to check if there is collision in front
    FHitResult CollisionCheckHitResult;
    
    bool bHit = GetWorld()->LineTraceSingleByChannel(
        CollisionCheckHitResult,
        FishLocation,
        EndLocation,
        ECC_Visibility,
        QueryParams
    );

    if(DrawDebug)
    {
        // Draw the debug point at the specified location
        DrawDebugLine(
            GetWorld(),
            FishLocation,
            EndLocation,        
            bHit ? FColor::Red : FColor::Green,
            false,
            0.1f
        );    
    }
    
    if(bHit)
    {
        return PerformLineTracesForCollisionAvoidance(FishLocation, CollisonAvoidanceTraceDistance, FishIndex, FishTransform); //cone line trace in front of fish to find right direction
    }
    
    return FVector::ZeroVector; //if not hit don't return force
}

void AAIFishSchoolPawn::InitializeViewDirections()
{
    ViewDirections.SetNum(NumViewDirections);
    
    float GoldenRatio = (1 + FMath::Sqrt(5.0f)) / 2.0f;  // Golden ratio
    float AngleIncrement = PI * 2.0f * GoldenRatio;       // Angle increment
    
    for (int32 i = 0; i < NumViewDirections; i++)
    {
        float t = static_cast<float>(i) / static_cast<float>(NumViewDirections);
        float Inclination = FMath::Acos(1 - 2 * t);  // Vertical angle
        float Azimuth = AngleIncrement * i;          // Horizontal angle

        // Convert spherical coordinates to Cartesian coordinates
        float x = FMath::Sin(Inclination) * FMath::Cos(Azimuth);
        float y = FMath::Sin(Inclination) * FMath::Sin(Azimuth);
        float z = FMath::Cos(Inclination);

        ViewDirections[i] = FVector(x, y, z); ViewDirections[i];
        ViewDirections[i] = ViewDirections[i].RotateAngleAxis(90, FVector(1,0,0)).RotateAngleAxis(90, FVector(0,0,1));
    }
}

// Method to perform line traces using the generated directions
FVector AAIFishSchoolPawn::PerformLineTracesForCollisionAvoidance(const FVector& StartLocation, float TraceDistance, int32 FishIndex, FTransform FishTransform)
{
    // Ensure directions are initialized
    
    if (ViewDirections.Num() == 0)
    {
        InitializeViewDirections(); //get directions of the line to line trace in cone shape
    }
    
    FCollisionQueryParams QueryParams;
    QueryParams.AddIgnoredActor(this);  // Ignore the current actor (self)
    QueryParams.AddIgnoredComponent(InstancedMeshComponent);
    
    for (const FVector& Direction : ViewDirections) //for each direction do line trace
    {
        FVector GlobalDirection = FishTransform.TransformVector(Direction);
        FVector AvoidDirection = GlobalDirection;
        FVector EndLocation = StartLocation + (GlobalDirection * TraceDistance);
        
        FHitResult HitResult;
        // perform line trace
        bool bHit = GetWorld()->LineTraceSingleByChannel(
            HitResult,
            StartLocation,
            EndLocation,
            ECC_Visibility,
            QueryParams
        );
        
        
        // draw debug
        if (GetWorld() && DrawDebug)
        {
            DrawDebugLine(
                GetWorld(),
                StartLocation,
                EndLocation,
                bHit ? FColor::Blue : FColor::Cyan,
                false,
                0.1,
                0,
                bHit ? 0 : 0.3
            );
        }

        if (!bHit) //if the line doesn't hit return that direction as direction to avoid collision
        {
            return AvoidDirection;
        }
    }
    return Velocities[FishIndex].GetSafeNormal();
}

FVector AAIFishSchoolPawn::SteerToward(FVector vector, FVector Velocity)
{
    if(vector.IsZero()){return FVector::ZeroVector;}
    FVector v = ( vector.GetSafeNormal() * MaxSpeed ) - Velocity;
    return v.GetClampedToMaxSize(MaxForce);
}

FVector AAIFishSchoolPawn::Seek(const FVector& TargetLocation, int32 FishIndex, FTransform FishTransform)
{
    FVector FishLocation = FishTransform.GetLocation();
    FVector Desired = (TargetLocation - FishLocation).GetSafeNormal() * MaxSpeed;
    FVector Steering = (Desired - Velocities[FishIndex]).GetClampedToMaxSize(MaxForce);
    return Steering;
}

`);
</script>